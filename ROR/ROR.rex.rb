#
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.0
# from lexical definition file "ROR.rex".
#

require 'racc/parser'
#
#   ROTR.rex - the lexical scanner for ROTR.racc
#   Copyright (C) 2010, 2011  Adam Oliver
# 
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU Affero General Public License as
#   published by the Free Software Foundation, either version 3 of the
#   License, or (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Affero General Public License for more details.
# 
#   You should have received a copy of the GNU Affero General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

class ROTR < Racc::Parser
  require 'strscan'

  class ScanError < StandardError ; end

  attr_reader :lineno
  attr_reader :filename

  def scan_setup ; end

  def action &block
    yield
  end

  def scan_str( str )
    scan_evaluate  str
    do_parse
  end

  def load_file( filename )
    @filename = filename
    open(filename, "r") do |f|
      scan_evaluate  f.read
    end
  end

  def scan_file( filename )
    load_file  filename
    do_parse
  end

  def next_token
    @rex_tokens.shift
  end

  def scan_evaluate( str )
    scan_setup
    @rex_tokens = []
    @lineno  =  1
    ss = StringScanner.new(str)
    state = nil
    until ss.eos?
      text = ss.peek(1)
      @lineno  +=  1  if text == "\n"
      case state
      when nil
        case
        when (text = ss.scan(/\s+/))
          ;

        when (text = ss.scan(/(#!.+)/))
           @rex_tokens.push action { [:HASHBANG, text] }

        when (text = ss.scan(/(<\?HAI)/))
           @rex_tokens.push action { state = :PARSE; [:HAI, text] }

        when (text = ss.scan(/.*/))
           @rex_tokens.push action { [:NONLOL, text] }

        else
          text = ss.string[ss.pos .. -1]
          raise  ScanError, "can not match: '" + text + "'"
        end  # if

      when :PARSE
        case
        when (text = ss.scan(/\s+/))
          ;

        when (text = ss.scan(/(VISIBLE)/))
           @rex_tokens.push action { [:VISIBLE, text] }

        when (text = ss.scan(/(KTHXBYE\?>)/))
           @rex_tokens.push action { state = nil; [:KTHXBYE, text] }

        when (text = ss.scan(/(CAN\sHAS\sMYSQL)/))
           @rex_tokens.push action { [:MYSQL, text] }

        when (text = ss.scan(/(MAEK\sDB)/))
           @rex_tokens.push action { [:MAEKDB, text] }

        when (text = ss.scan(/(UZE)/))
           @rex_tokens.push action { [:UZE, text] }

        when (text = ss.scan(/(MAEK\sTABELZ)/))
           @rex_tokens.push action { [:MAEKTABELZ, text] }

        when (text = ss.scan(/[(]/))
           @rex_tokens.push action { [:OP, text] }

        when (text = ss.scan(/[)]/))
           @rex_tokens.push action { [:CP, text] }

        when (text = ss.scan(/(IZ)/))
           @rex_tokens.push action { [:IZ, text] }

        when (text = ss.scan(/(YARN)/))
           @rex_tokens.push action { [:YARN, text] }

        when (text = ss.scan(/(EDIT)/))
           @rex_tokens.push action { [:EDIT, text] }

        when (text = ss.scan(/(DEL)/))
           @rex_tokens.push action { [:DEL, text] }

        when (text = ss.scan(/(NUMBR)/))
           @rex_tokens.push action { [:NUMBR, text] }

        when (text = ss.scan(/[0-9]+/))
           @rex_tokens.push action { [:POSINT, text] }

        when (text = ss.scan(/(GIMMEH)/))
           @rex_tokens.push action { [:GIMMEH, text] }

        when (text = ss.scan(/(FROM)/))
           @rex_tokens.push action { [:FROM, text] }

        when (text = ss.scan(/[*]/))
           @rex_tokens.push action { [:ASTERISK, text] }

        when (text = ss.scan(/[,]/))
           @rex_tokens.push action { [:COMMA, text] }

        when (text = ss.scan(/(ADDZ)/))
           @rex_tokens.push action { [:ADDZ, text] }

        when (text = ss.scan(/(BIGGR\sTHAN)/))
           @rex_tokens.push action { [:BIGGRTHAN, text] }

        when (text = ss.scan(/(SMALLR\sTHAN)/))
           @rex_tokens.push action { [:SMALLRTHAN, text] }

        when (text = ss.scan(/(BOTH\sSAEM)/))
           @rex_tokens.push action { [:BOTHSAEM, text] }

        when (text = ss.scan(/(YARLY)/))
           @rex_tokens.push action { [:YARLY, text] }

        when (text = ss.scan(/(NOWAI)/))
           @rex_tokens.push action { [:NOWAI, text] }

        when (text = ss.scan(/(WHERE)/))
           @rex_tokens.push action { [:WHERE, text] }

        when (text = ss.scan(/(GET_PARAMS)/))
           @rex_tokens.push action { [:GET_PARAMS, text] }

        when (text = ss.scan(/(>)/))
           @rex_tokens.push action { [:GT, text] }

        when (text = ss.scan(/(=)/))
           @rex_tokens.push action { [:EQ, text] }

        when (text = ss.scan(/(<)/))
           @rex_tokens.push action { [:LT, text] }

        when (text = ss.scan(/(LIEK)/))
           @rex_tokens.push action { [:LIEK, text] }

        when (text = ss.scan(/(I\sHAS\sA)/))
           @rex_tokens.push action { [:IHASA, text] }

        when (text = ss.scan(/(ITZ)/))
           @rex_tokens.push action { [:ITZ, text] }

        when (text = ss.scan(/(BTW).*/))
          ;

        when (text = ss.scan(/(KTHX)/))
           @rex_tokens.push action { [:KTHX, text] }

        when (text = ss.scan(/([A-Za-z]+)/))
           @rex_tokens.push action { [:WORD, text] }

        when (text = ss.scan(/["][^"]+["]/))
           @rex_tokens.push action { [:STRING, text] }

        else
          text = ss.string[ss.pos .. -1]
          raise  ScanError, "can not match: '" + text + "'"
        end  # if

      else
        raise  ScanError, "undefined state: '" + state.to_s + "'"
      end  # case state
    end  # until ss
  end  # def scan_evaluate

end # class
